// Event Section Starts
// Initialize Supabase client for events
const eventsSupabaseUrl = "https://csmiziefiecrtxdmahef.supabase.co";
const eventsSupabaseKey = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNzbWl6aWVmaWVjcnR4ZG1haGVmIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTA5MzI4MjYsImV4cCI6MjA2NjUwODgyNn0.foiIv2NTxY60h9uKOtvGA3g1mhkA_8bPormy6_ml_KM";
const eventsSupabaseClient = supabase.createClient(eventsSupabaseUrl, eventsSupabaseKey);

// Events horizontal scroll functionality
class EventsHorizontalScroll {
    constructor() {
        this.events = [];
        this.container = null;
        this.track = null;
        this.isAutoScrolling = false;
        this.autoScrollInterval = null;
        this.pauseTimeout = null;
        this.isUserInteracting = false;
        this.scrollDirection = 1; // 1 for right, -1 for left
        this.autoScrollSpeed = 320; // pixels per frame
        this.pauseDuration = 2000; // 5 seconds
        this.returnDuration = 1000; // 1 second to return to start
        
        this.init();
    }
    
    async init() {
        try {
            await this.loadEvents();
            this.setupElements();
            this.renderEvents();
            this.setupEventListeners();
            this.startAutoScroll();
        } catch (error) {
            console.error('Failed to initialize events scroll:', error);
            this.showError();
        }
    }
    
    async loadEvents() {
        const { data, error } = await eventsSupabaseClient
            .from('events')
            .select('*')
            .order('start_date', { ascending: true });
        
        if (error) throw error;
        
        // Sort events by proximity to current date
        const now = new Date();
        this.events = (data || []).sort((a, b) => {
            const dateA = new Date(a.start_date);
            const dateB = new Date(b.start_date);
            
            const relevantDateA = dateA >= now ? dateA : new Date(a.end_date);
            const relevantDateB = dateB >= now ? dateB : new Date(b.end_date);
            
            const diffA = Math.abs(relevantDateA - now);
            const diffB = Math.abs(relevantDateB - now);
            
            return diffA - diffB;
        });
    }
    
    setupElements() {
        this.container = document.querySelector('.events-scroll-container');
        this.track = document.getElementById('eventsScrollTrack');
        this.eventsSection = document.querySelector('.events-section');
    }
    
    renderEvents() {
        if (!this.track) return;
        
        if (this.events.length === 0) {
            this.showNoEvents();
            return;
        }
        
        // Clear existing content
        this.track.innerHTML = '';
        this.track.classList.remove('no-events');
        this.container.classList.remove('no-events');
        this.eventsSection.classList.remove('no-events');
        
        // Create event cards
        this.events.forEach((event) => {
            const card = this.createEventCard(event);
            this.track.appendChild(card);
        });
    }
    
    createEventCard(event) {
        const card = document.createElement('div');
        card.className = 'events-card';
        
        const startDate = new Date(event.start_date);
        const endDate = new Date(event.end_date);
        const formatDate = (date) => {
            return `${date.getDate().toString().padStart(2, '0')}/${(date.getMonth() + 1).toString().padStart(2, '0')}/${date.getFullYear()}`;
        };
        
        const modeText = event.mode === 'online' ? 'Online Event' : 'Offline Event';
        
        card.innerHTML = `
            <div class="events-card-image">
                <img src="${event.poster_url || '/api/placeholder/350/200'}" 
                     alt="${event.event_name}" 
                     onerror="this.src='/api/placeholder/350/200'">
            </div>
            <div class="events-card-content">
                <h3 class="events-card-title">${event.event_name}</h3>
                <p class="events-card-mode">${modeText}</p>
                <p class="events-card-dates">From: ${formatDate(startDate)} To: ${formatDate(endDate)}</p>
                <p class="events-card-location">Location: ${event.location}</p>
                <div class="events-card-buttons">
                    <button class="events-card-btn view-poster-btn" onclick="eventsHorizontalScroll.viewPoster('${event.poster_url}', '${event.event_name}')">
                        <span>View Poster</span>
                        <div class="shine-effect"></div>
                    </button>
                    <a href="${event.registration_link}" target="_blank" class="events-card-btn">
                        <span>Register</span>
                        <div class="shine-effect"></div>
                    </a>
                </div>
            </div>
        `;
        
        return card;
    }
    
    setupEventListeners() {
        if (!this.container) return;
        
        // Mouse events
        this.container.addEventListener('mouseenter', () => this.pauseAutoScroll());
        this.container.addEventListener('mouseleave', () => this.scheduleResumeAutoScroll());
        
        // Scroll events
        this.container.addEventListener('scroll', () => this.handleUserScroll());
        
        // Touch events
        this.container.addEventListener('touchstart', () => this.pauseAutoScroll(), { passive: true });
        this.container.addEventListener('touchend', () => this.scheduleResumeAutoScroll(), { passive: true });
        
        // Card interaction events
        if (this.track) {
            this.track.addEventListener('click', () => {
                this.pauseAutoScroll();
                this.scheduleResumeAutoScroll();
            });
        }
        
        // Keyboard events
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                this.pauseAutoScroll();
                this.scheduleResumeAutoScroll();
            }
        });
    }
    
    handleUserScroll() {
        this.isUserInteracting = true;
        this.pauseAutoScroll();
        this.scheduleResumeAutoScroll();
    }
    
    startAutoScroll() {
        if (this.events.length <= this.getVisibleCardCount()) return;
        
        this.stopAutoScroll();
        this.isAutoScrolling = true;
        
        const scroll = () => {
            if (!this.isAutoScrolling || this.isUserInteracting) return;
            
            const maxScroll = this.container.scrollWidth - this.container.clientWidth;
            const currentScroll = this.container.scrollLeft;
            
            if (this.scrollDirection === 1) {
                // Scrolling right
                if (currentScroll >= maxScroll) {
                    // Reached end, return to start
                    this.returnToStart();
                    return;
                }
                this.container.scrollLeft += this.autoScrollSpeed;
            }
            
            requestAnimationFrame(scroll);
        };
        
        requestAnimationFrame(scroll);
    }
    
    returnToStart() {
        this.isAutoScrolling = false;
        
        // Smooth scroll back to start
        this.container.scrollTo({
            left: 0,
            behavior: 'smooth'
        });
        
        // Resume auto scroll after return animation
        setTimeout(() => {
            if (!this.isUserInteracting) {
                this.startAutoScroll();
            }
        }, this.returnDuration);
    }
    
    stopAutoScroll() {
        this.isAutoScrolling = false;
        
        if (this.autoScrollInterval) {
            clearInterval(this.autoScrollInterval);
            this.autoScrollInterval = null;
        }
    }
    
    pauseAutoScroll() {
        this.isUserInteracting = true;
        this.stopAutoScroll();
        
        if (this.pauseTimeout) {
            clearTimeout(this.pauseTimeout);
            this.pauseTimeout = null;
        }
    }
    
    scheduleResumeAutoScroll() {
        if (this.pauseTimeout) {
            clearTimeout(this.pauseTimeout);
        }
        
        this.pauseTimeout = setTimeout(() => {
            this.isUserInteracting = false;
            this.startAutoScroll();
        }, this.pauseDuration);
    }
    
    getVisibleCardCount() {
        const containerWidth = this.container.clientWidth;
        const cardWidth = 350 + 30; // card width + gap
        
        if (window.innerWidth <= 768) {
            return 1; // Mobile
        } else {
            return Math.floor(containerWidth / cardWidth);
        }
    }
    
    showNoEvents() {
        if (this.track) {
            this.track.innerHTML = '<div class="events-no-data">No events yet</div>';
            this.track.classList.add('no-events');
        }
        
        this.container.classList.add('no-events');
        this.eventsSection.classList.add('no-events');
    }
    
    showError() {
        if (this.track) {
            this.track.innerHTML = '<div class="events-no-data">Error loading events</div>';
            this.track.classList.add('no-events');
        }
        
        this.container.classList.add('no-events');
        this.eventsSection.classList.add('no-events');
    }
    
    viewPoster(posterUrl, eventName) {
        if (!posterUrl) return;
        
        this.pauseAutoScroll();
        this.scheduleResumeAutoScroll();
        
        let modal = document.getElementById('eventsModal');
        if (!modal) {
            modal = this.createModal();
        }
        
        const modalImg = document.getElementById('eventsModalImg');
        modalImg.src = posterUrl;
        modalImg.alt = eventName;
        modal.style.display = 'block';
    }
    
    createModal() {
        const modal = document.createElement('div');
        modal.id = 'eventsModal';
        modal.style.cssText = `
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            cursor: pointer;
        `;
        
        const modalContent = document.createElement('div');
        modalContent.style.cssText = `
            position: relative;
            margin: auto;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            max-width: 95%;
            max-height: 95%;
        `;
        
        const modalImg = document.createElement('img');
        modalImg.id = 'eventsModalImg';
        modalImg.style.cssText = `
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        `;
        
        const closeBtn = document.createElement('span');
        closeBtn.innerHTML = '&times;';
        closeBtn.style.cssText = `
            position: absolute;
            top: 15px;
            right: 25px;
            color: white;
            font-size: 60px;
            font-weight: bold;
            cursor: pointer;
            z-index: 2001;
        `;
        
        modalContent.appendChild(modalImg);
        modal.appendChild(closeBtn);
        modal.appendChild(modalContent);
        document.body.appendChild(modal);
        
        // Event listeners
        modal.addEventListener('click', () => this.closeModal());
        closeBtn.addEventListener('click', () => this.closeModal());
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') this.closeModal();
        });
        
        return modal;
    }
    
    closeModal() {
        const modal = document.getElementById('eventsModal');
        if (modal) {
            modal.style.display = 'none';
        }
    }
    
    destroy() {
        this.stopAutoScroll();
        
        if (this.pauseTimeout) {
            clearTimeout(this.pauseTimeout);
        }
    }
}

// Initialize horizontal scroll when DOM is loaded
let eventsHorizontalScroll;

document.addEventListener('DOMContentLoaded', () => {
    eventsHorizontalScroll = new EventsHorizontalScroll();
});

// Cleanup on page unload
window.addEventListener('beforeunload', () => {
    if (eventsHorizontalScroll) {
        eventsHorizontalScroll.destroy();
    }
});
// Event Section Ends